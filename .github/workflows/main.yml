name: CI/CD Pipeline

on:
  push:
    branches:
      - main

jobs:
  # Provision infrastructure using Terraform
  provision_infra:
    name: Provision Infrastructure (Terraform)
    runs-on: ubuntu-latest

    env:
      TF_API_TOKEN: ${{ secrets.TF_API_TOKEN }}
      TF_VAR_do_token: ${{ secrets.DO_TOKEN }}
      TF_VAR_ssh_key_name: ${{ secrets.SSH_KEY_NAME }}

    outputs:
      droplet_ip: ${{ steps.output_ip.outputs.droplet_ip }}

    steps:
      # Checkout the repository
      - name: Checkout repository
        uses: actions/checkout@v4

      # Setup Terraform CLI
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.6
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

      # Initialize Terraform
      - name: Terraform Init
        working-directory: terraform
        run: terraform init -input=false

      # Apply Terraform configuration (create droplet)
      - name: Terraform Apply
        working-directory: terraform
        run: terraform apply -auto-approve -input=false

      # Capture droplet IP as output
      - name: Get Droplet IP
        id: output_ip
        working-directory: terraform
        run: |
          IP=$(terraform output -raw droplet_ip)
          echo "droplet_ip=$IP" >> $GITHUB_OUTPUT

  # Run tests, build Docker image, and push to Docker Hub
  main:
    name: CI, Build and Deploy
    runs-on: ubuntu-latest
    needs: provision_infra

    steps:
      # 1) Source code checkout
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2) Spin up containers for tests (development docker-compose)
      - name: Start services for tests
        run: |
          cp .env.example .env
          docker compose up -d --build
          # wait a bit for Postgres to be ready
          sleep 15

      # 3) Run pytest inside the app container
      - name: Run unit tests with pytest
        run: |
          docker compose exec app pytest

      # 4) Tear down test environment (always, even if tests fail)
      - name: Stop services
        if: always()
        run: |
          docker compose down -v

      # 5) Log in to Docker Hub
      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # 6) Define Docker image tag based on the commit SHA
      - name: Set image tag
        id: meta
        run: |
          SHA=${GITHUB_SHA::7}
          echo "tag=$SHA" >> $GITHUB_OUTPUT

      # 7) Build and push Docker image to Docker Hub
      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: |
            ${{ secrets.DOCKER_IMAGE_NAME }}:${{ steps.meta.outputs.tag }}
            ${{ secrets.DOCKER_IMAGE_NAME }}:latest

      # 8) Deploy to remote server via SSH
      - name: Deploy to production server
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ needs.provision_infra.outputs.droplet_ip }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          script: |
            set -e

            # Wait for cloud-init to finish provisioning the server
            while [ ! -f /var/lib/cloud/instance/boot-finished ]; do
              sleep 5
            done

            # Ensure docker-compose (v1) is available on the server
            if ! command -v docker-compose >/dev/null 2>&1; then
              sudo apt-get update -y
              sudo apt-get install -y docker-compose
            fi

            cd ${{ secrets.SERVER_APP_PATH }}

            # Update repository (docker-compose.prod.yml, etc.)
            git pull origin main

            # Set environment variables used by docker-compose.prod.yml
            echo "DOCKER_IMAGE_NAME=${{ secrets.DOCKER_IMAGE_NAME }}" > .env
            echo "DOCKER_IMAGE_TAG=${{ steps.meta.outputs.tag }}" >> .env

            # Drops old containers, but keeps volumes (DB is not deleted)
            docker-compose -f docker-compose.prod.yml down || true

            # Pull the new image and restart the application using the production compose file
            docker-compose --env-file .env -f docker-compose.prod.yml pull app
            docker-compose --env-file .env -f docker-compose.prod.yml up -d
